"""Prompt Chaining using Costte and Cosma."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_prompt_chaining.ipynb.

# %% auto 0
__all__ = ['Chain', 'extract_xml']

# %% ../02_prompt_chaining.ipynb 4
from .core import Agent
from dataclasses import dataclass, field
from typing import List, Callable, Dict, Any, Optional
from fastcore.basics import patch
import re
import json
from cosette import models
from toolslm.xml import json_to_xml, docs_xml, mk_doctype


# %% ../02_prompt_chaining.ipynb 6
@dataclass
class Chain:
    """A sequence of agents that process information with flexible input/output types and validation"""
    name: str
    agents: List[Agent] = field(default_factory=list)
    steps: List[dict] = field(default_factory=list)
    input_type: str = "text"  # text, image, mixed, structured
    output_type: str = "text"
    validators: List[Callable] = field(default_factory=list)
    
    def __post_init__(self):
        """Initialize chain with type checking and validation setup"""
        self.history = []
        
    @property
    def use(self):
        """Track token usage across chain"""
        return sum((a.chat.use for a in self.agents), start=0)
    
    def validate(self, step_output, step_num):
        """Run validators appropriate for the output type"""
        results = []
        for v in self.validators:
            results.append(v(step_output))
        return all(results)

# %% ../02_prompt_chaining.ipynb 7
@patch
def __call__(self:Chain, x):
    """Execute the chain on input x"""
    result = x
    for a in self.agents:
        curr_input = result
        result = a.run_with_tools(result)
        self.steps.append(dict(agent=a, input=curr_input, output=result))
    return result

# %% ../02_prompt_chaining.ipynb 8
@patch
def show(self:Chain):
    """Display chain execution with clear, readable formatting"""
    md = [f"# {self.name}\n"]
    
    # Show chain structure
    md.append("## Structure")
    for i,a in enumerate(self.agents): 
        md.append(f"{i+1}. {a.role}")
        if i < len(self.agents)-1: md.append("   ↓")
    
    # Show execution steps
    if self.steps:
        md.append("\n## Execution")
        for i,s in enumerate(self.steps):
            md.append(f"\nStep {i+1}: {s['agent'].role}")
            md.append(f"\nInput:\n```\n{s['input']}\n```")
            md.append(f"\nOutput:\n```\n{s['output']}\n```")
            if i < len(self.steps)-1: md.append("\n   ↓")
    
    return "\n".join(md)


# %% ../02_prompt_chaining.ipynb 16
def extract_xml(text: str, tag: str) -> str:
    """Extract content from XML tags, including CDATA sections"""
    pattern = f'<{tag}>\s*(?:<!\[CDATA\[)?(.*?)(?:\]\]>)?\s*</{tag}>'
    match = re.search(pattern, text, re.DOTALL)
    return match.group(1).strip() if match else ""
